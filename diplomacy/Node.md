trait InwardNodeImp[DI, UI, EI, BI <: Data]
-------------------------------
*Typeclass for inward node*

+ *DI*: Downwards flowing Parameters received on the inner side of the node
+ *UI*: Upwards flowing Parameters generated by the inner side of the node
+ *EI*: Edge Parameters describing a connection on the inner side of the node
+ *BI*: Bundle type used when connecting to the inner side of the node
+ *edgeI: (pd: DI, pu: UI) => EI*:<br> **TODO** Generate parameters for inner edge??
+ *bundleI: (ei: Seq[EI]) => Vec[BI]*:<br> **TODO** Generate inner connections??
+ *colour: _ => String*:<br> return color in node graph
+ *connect: (bindings: () => Seq[(EI, BI, BI)])(implicit p: Parameters, sourceInfo: SourceInfo) => (Option[LazyModule], () => Unit)*:<br> **TODO** connect internal module components??

trait OutwardNodeImp[DO, UO, EO, BO <: Data]
------------------------------
*Typeclass for an outward node*

+ *DO*: Downwards flowing Parameters generated by the outer side of the node
+ *UO*: Upwards   flowing Parameters received on the outer side of the node
+ *EO*: Edge Parameters describing a connection on the outer side of the node
+ *BO*: Bundle type used when connecting to the outer side of the node
+ *edgeO: (pd: DO, pu: UO) => EO* <br> **TODO** ??
+ *bundleO: (eo: Seq[EO]) => Vec[BO]* <br> **TODO** ??

abstract class NodeImp[D, U, EO, EI, B <: Data]
--------------------------------
    abstract class NodeImp[D, U, EO, EI, B <: Data]
      extends Object with InwardNodeImp[D, U, EI, B] with OutwardNodeImp[D, U, EO, B]

abstract class BaseNode
---------------------------
*Base class of all Node classes*

+ *lazyModule: LazyModule*: ??
+ *index: Int*: ??
+ *externalIn: Boolean*: ??
+ *externalOut: Boolean*: ??
+ *nodename: _ => String*: get node name
+ *name: _ => String*: get hierarchical node name ??
+ *omitGraphML: _ => Bool*: omit graph generation when no inner or no outer nodes
+ *gci: _ => Option[BaseNode]*: get the greatest common inner node type
+ *gco: _ => Option[BaseNode]*: get the greatest common outer node type
+ *outputs: _ => Seq[(BaseNode, String)]*: list of outer nodes
+ *inputs: _ => Seq[(BaseNode, String)]*: list of inner nodes
+ *colour: _ => String*: node color



case class NodeHandle[DI, UI, BI <: Data, DO, UO, BO <: Data]
---------------------------
    case class NodeHandle[DI, UI, BI <: Data, DO, UO, BO <: Data]
      (inward: InwardNode[DI, UI, BI], outward: OutwardNode[DO, UO, BO])
      extends Object with InwardNodeHandle[DI, UI, BI] with OutwardNodeHandle[DO, UO, BO]


trait InwardNodeHandle[DI, UI, BI <: Data]
---------------------------

+ *inward: InwardNode[DI, UI, BI]*: self object pointer
+ *operator (:=): OutwardNodeHandle => Option[LazyModule]*: <br> **TODO** get a LazyModule for inward from outward??
+ *operator (&ast;=): OutwardNodeHandle => Option[LazyModule]*: <br> **TODO** get a LazyModule for inward from outward??
+ *operator (=&ast;): OutwardNodeHandle => Option[LazyModule]*: <br> **TODO** get a LazyModule for inward from outward??

case object BIND\_ONCE
---------------------------------

case object BIND\_QUERY
---------------------------------

case object BIND\_STAR
---------------------------------


trait InwardNode[DI, UI, BI <: Data]
------------------------
    trait InwardNode[DI, UI, BI <: Data] extends BaseNode with InwardNodeHandle[DI, UI, BI]

+ *inward: InwardNode[DI, UI, BI]*: self object pointer
+ *numPI: Range.Inclusive*: number of inputs (numPI >= 0)
+ *accPI: ListBuffer[(Int, OutwardNode[DI, UI, BI], NodeBinding)]*: private, list of inputs (input, node, binding)
+ *iRealized: Boolean*: ??
+ *iPushed: _ => Int*: number of inputs been processed
+ *iPush: (node:Int, node: OutwardNode[DI, UI, BI], binding: NodeBinding) => Unit*: push an input to accPI

