[Rocket](../Readme.md)/[diplomacy](../diplomacy.md)/[Node](https://github.com/ucb-bar/rocket-chip/blob/master/src/main/scala/diplomacy/Node.scala)
=====================

**********************

trait InwardNodeImp[DI, UI, EI, BI <: Data]
-------------------------------
*Typeclass for inward node*

+ *DI*: Downwards flowing Parameters received on the inner side of the node
+ *UI*: Upwards flowing Parameters generated by the inner side of the node
+ *EI*: Edge Parameters describing a connection on the inner side of the node
+ *BI*: Bundle type used when connecting to the inner side of the node
+ *edgeI: (pd: DI, pu: UI) => EI*:<br> **TODO** Generate parameters for inner edge??
+ *bundleI: (ei: Seq[EI]) => Vec[BI]*:<br> **TODO** Generate inner connections??
+ *colour: _ => String*:<br> return color in node graph
+ *connect: (bindings: () => Seq[(EI, BI, BI)])(implicit p: Parameters, sourceInfo: SourceInfo) => (Option[LazyModule], () => Unit)*:<br> **TODO** connect internal module components??

trait OutwardNodeImp[DO, UO, EO, BO <: Data]
------------------------------
*Typeclass for an outward node*

+ *DO*: Downwards flowing Parameters generated by the outer side of the node
+ *UO*: Upwards   flowing Parameters received on the outer side of the node
+ *EO*: Edge Parameters describing a connection on the outer side of the node
+ *BO*: Bundle type used when connecting to the outer side of the node
+ *edgeO: (pd: DO, pu: UO) => EO* <br> **TODO** ??
+ *bundleO: (eo: Seq[EO]) => Vec[BO]* <br> **TODO** ??

abstract class NodeImp[D, U, EO, EI, B <: Data]
--------------------------------
    abstract class NodeImp[D, U, EO, EI, B <: Data]
      extends Object with InwardNodeImp[D, U, EI, B] with OutwardNodeImp[D, U, EO, B]

abstract class BaseNode
---------------------------
*Base class of all Node classes*

+ *lazyModule: LazyModule*: ??
+ *index: Int*: ??
+ *externalIn: Boolean*: ??
+ *externalOut: Boolean*: ??
+ *nodename: _ => String*: get node name
+ *name: _ => String*: get hierarchical node name ??
+ *omitGraphML: _ => Bool*: omit graph generation when no inner or no outer nodes
+ *gci: _ => Option[BaseNode]*: get the greatest common inner node type
+ *gco: _ => Option[BaseNode]*: get the greatest common outer node type
+ *outputs: _ => Seq[(BaseNode, String)]*: list of outer nodes
+ *inputs: _ => Seq[(BaseNode, String)]*: list of inner nodes
+ *colour: _ => String*: node color



case class NodeHandle[DI, UI, BI <: Data, DO, UO, BO <: Data]
---------------------------
    case class NodeHandle[DI, UI, BI <: Data, DO, UO, BO <: Data]
      (inward: InwardNode[DI, UI, BI], outward: OutwardNode[DO, UO, BO])
      extends Object with InwardNodeHandle[DI, UI, BI] with OutwardNodeHandle[DO, UO, BO]


case object BIND\_ONCE
---------------------------------
*Normal one to one connection*

case object BIND\_QUERY
---------------------------------
*A shared sink port?*

case object BIND\_STAR
---------------------------------
*A shared source port?*


trait InwardNodeHandle[DI, UI, BI <: Data]
---------------------------

+ *inward: InwardNode[DI, UI, BI]*: self object pointer
+ **:=** `(h: OutwardNodeHandle[DI, UI, BI]) => Option[LazyModule]`

    Connect this input port to an output port `h`.

+ **&ast;=** `(h: OutwardNodeHandle[DI, UI, BI]) => Option[LazyModule]`

    Connect this input multi-port to an output `h`??

+ **=&ast;** `(h: OutwardNodeHandle[DI, UI, BI]) => Option[LazyModule]`

    Connect this input port to an output multi-port `h`??


trait InwardNode[DI, UI, BI <: Data]
------------------------
    trait InwardNode[DI, UI, BI <: Data] extends BaseNode with InwardNodeHandle[DI, UI, BI]

+ *inward: InwardNode[DI, UI, BI]*: self object pointer
+ *numPI: Range.Inclusive*: number of inner nodes (numPI >= 0)
+ *iPushed: _ => Int*: number of inner nodes being processed
+ *iPush: (node:Int, node: OutwardNode[DI, UI, BI], binding: NodeBinding) => Unit*: process an inner node
+ *iBindings: List[(Int, OutwardNode[DI, UI, BI], NodeBinding)]*: list of inner nodes (index, input, binding)
+ *iStar: Int*: ??
+ *iPortMapping: Seq[(Int, Int)]*: range of each inner nodes
+ *iParams: Seq[UI]*: inner node parameters
+ *bundleIn: Vec[BI]*: inner node bundles

trait OutwardNodeHandle[DO, UO, BO <: Data]
---------------------------

+ *outward: OutwardNode[DO, UO, BO]*: self object pointer


trait OutwardNode[DO, UO, BO <: Data]
----------------------------
    trait OutwardNode[DO, UO, BO <: Data] extends BaseNode with OutwardNodeHandle[DO, UO, BO]

+ *outward: OutwardNode[DO, UO, BO]*: self object pointer
+ *numPO: Range.Inclusive*: number of putputs (numPO >= 0)
+ *oPushed: _ => Int*: number of outer nodes being processed
+ *oPush: (index: Int, node: InwardNode [DO, UO, BO], binding: NodeBinding) => Unit*: process an outer node
+ *oBindings: List[(Int, InwardNode [DO, UO, BO], NodeBinding)]*: list of outer nodes (index, output, binding)
+ *oStar: Int*: ??
+ *oPortMapping: Seq[(Int, Int)]*: Range of each outer nodes
+ *oParams: Seq[DO]*: outer node parameters
+ *bundleOut: vec[BO]*: outer node bundles


abstract class MixedNode[DI, UI, EI, BI <: Data, DO, UO, EO, BO <: Data]
---------------------------
~~~scala
abstract class MixedNode[DI, UI, EI, BI <: Data, DO, UO, EO, BO <: Data](
    inner: InwardNodeImp [DI, UI, EI, BI],
    outer: OutwardNodeImp[DO, UO, EO, BO])(
    protected[diplomacy] val numPO: Range.Inclusive,
    protected[diplomacy] val numPI: Range.Inclusive)
    extends BaseNode with InwardNode[DI, UI, BI] with OutwardNode[DO, UO, BO]
~~~

+ *oPorts: (Int, (Int, InwardNode [DO, UO, BO]))*: mapping from outer node to inner nodes?
+ *iPorts: (Int, (Int, OutwardNode [DO, UO, BO]))*: mapping from inner node to outer nodes?

....

**********************

```scala
last modified = 14/03/2017
authors       = Wei Song <wsong83@gmail.com>
license       = CC-BY <https://creativecommons.org/licenses/by/3.0/>
```
