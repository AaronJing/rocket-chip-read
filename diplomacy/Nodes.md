[Rocket](../Readme.md)/[diplomacy](../diplomacy.md)/[Node](https://github.com/freechipsproject/rocket-chip/blob/master/src/main/scala/diplomacy/Nodes.scala)
=====================
*The base classes of nodes on on-chip interconnects.*

**********************

trait InwardNodeImp
-------------------------------
*Typeclass for nodes with input channels.*

~~~scala
trait InwardNodeImp[DI, UI, EI, BI <: Data]
~~~

+ **DI** (type) downwards flowing Parameters received on the inner side of the node
+ **UI** (type) upwards flowing Parameters generated by the inner side of the node
+ **EI** (type) packet parameters (generators) for this node.
+ **BI** (type) bundle type
+ **edgeI** `(pd: DI, pu: UI) => EI` (virtual) get the parameters for an input channel.
+ **bundleI** `(ei: EI) => BI` (virtual) generate the input channel.
+ **colour** `() => String` (virtual) get the color in node connection graph.
+ **connect** `(()=>Seq[EI], ()=>Seq[(BI, BI)], enM:Boolean) => (m:Option[LazyModule], bind:()=>Unit)`<br>
    Generate the port connection callback function _bind()_<br>
    _enM_: whether to insert a bus monitor.<br>
    _m_: The optional monitor node to be connected.<br>
    _bind_: The actual connection procedure to be called later by LazyModule.
+ **mixI** `(pu: UI, InwardNode[DI, UI, BI]) => UI = pu` insert node into parameters.
+ **getO** `(pu: UI) => Option[BaseNode] = None` most-outward common node.

trait OutwardNodeImp
------------------------------
*Typeclass for nodes with output channels.*

~~~scala
trait OutwardNodeImp[DO, UO, EO, BO <: Data]
~~~

+ **DO** (type) downwards flowing Parameters generated by the outer side of the node
+ **UO** (type) upwards flowing Parameters received on the outer side of the node
+ **EO** (type) edge Parameters describing a connection on the outer side of the node
+ **BO** (type) bundle type used when connecting to the outer side of the node
+ **edgeO** `(pd: DO, pu: UO) => EO` (virtual) get the parameters for an output channel.
+ **bundleO** `(eo: EO) => BO` (virtual) generate the output channel.
+ **mixO** `(pd: DO, OutwardNode[DO, UO, BO]) => DO = pd`  insert node into parameters.
+ **getI** `(pd: DO) => Option[BaseNode] = None` most-inward common node.

abstract class NodeImp
--------------------------------
*Abstract root of nodes*

~~~scala
abstract class NodeImp[D, U, EO, EI, B <: Data]
  extends Object with InwardNodeImp[D, U, EI, B] with OutwardNodeImp[D, U, EO, B]
~~~

~~~diff
- Why differ EO and EI but not B?
~~~

abstract class BaseNode
---------------------------
*Base class of all Node parameter*

+ **lazyModule** `LazyModule` pointer to the parent lazyModule for error report.
+ **index** `Int` index of this node in stack.
+ **externalIn** `Boolean` (virtual) generate input bundle for external port connection.
+ **externalOut** `Boolean` (virtual) generate output bundle for external port connection.
+ **nodename** `() => String` node name
+ **name** `() => String` hierarchical node name
+ **omitGraphML** `() => Bool` a portless node does not need a connection graph
+ **gci** `() => Option[BaseNode]` get the greatest common inner node type
+ **gco** `() => Option[BaseNode]` get the greatest common outer node type
+ **outputs** `() => Seq[(BaseNode, String)]` list of outer nodes
+ **inputs** `() => Seq[(BaseNode, String)]` list of inner nodes
+ **colour** `() => String` node color



case class NodeHandle
---------------------------

~~~scala
case class NodeHandle[DI, UI, BI <: Data, DO, UO, BO <: Data]
    (inward: InwardNode[DI, UI, BI], outward: OutwardNode[DO, UO, BO])
    extends Object with InwardNodeHandle[DI, UI, BI] with OutwardNodeHandle[DO, UO, BO]
~~~

+ **inward** `InwardNode[DI, UI, BI]` (param).
+ **outward** `OutwardNode[DO, UO, BO]` (param).


trait NodeBinding
---------------------------
*Always look from the input port's perspective.*

~~~scala
sealed trait NodeBinding
case object BIND_ONCE  extends NodeBinding
case object BIND_QUERY extends NodeBinding
case object BIND_STAR  extends NodeBinding
~~~

+ **BIND\_ONCE**<br>
  Label normal one to one connection.
+ **BIND\_QUERY**<br>
  Label inputs of 1-to-M (demux) or outputs of M-to-1 (mux).
+ **BIND\_STAR**<br>
  Label outputs of 1-to-M (demux) or inputs of M-to-1 (mux).


trait InwardNodeHandle
---------------------------

~~~scala
trait InwardNodeHandle[DI, UI, BI <: Data]
{
    val inward: InwardNode[DI, UI, BI]
}
~~~

+ *inward: InwardNode[DI, UI, BI]*: (virtual) self object pointer
+ **:=** `(h: OutwardNodeHandle[DI, UI, BI]) => Option[MonitorBase]` (virtual) 1-to-1 bind.
+ **&ast;=** `(h: OutwardNodeHandle[DI, UI, BI]) => Option[MonitorBase]` (virtual) 1-to-M bind.
+ **=&ast;** `(h: OutwardNodeHandle[DI, UI, BI]) => Option[MonitorBase]` (virtual) M-to-1 bind.

trait InwardNode
------------------------

~~~scala
trait InwardNode[DI, UI, BI <: Data] extends BaseNode with InwardNodeHandle[DI, UI, BI]
~~~

+ **inward** `InwardNode[DI, UI, BI] = this` pointer to the LazyModule.
+ **numPI** `Range.Inclusive` (virtual) range of input ports.
+ **iPushed** `() => Int` number of inner nodes being processed.
+ **iPush** `(node:Int, node: OutwardNode[DI, UI, BI], binding: NodeBinding) => Unit`<br>
  Process a port connection.
+ **iBindings** `List[(Int, OutwardNode[DI, UI, BI], NodeBinding)]`<br>
  (lazy) A list of output ports to be binded (index, port, bind-type).
+ **iStar** `Int` (virtual) ??
+ **iPortMapping** `Seq[(Int, Int)]` (virtual) range of each input port.
+ **iParams** `Seq[UI]` (virtual) input port parameters.
+ **bundleIn** `Vec[BI]` (virtual) the actual heterogeneous list of input port Bundles in hardware.

trait OutwardNodeHandle
---------------------------

~~~scala
trait OutwardNodeHandle[DO, UO, BO <: Data]
{
  val outward: OutwardNode[DO, UO, BO]
}
~~~

+ **outward** `OutwardNode[DO, UO, BO]` (virtual) tpointer to the LazyModule.


trait OutwardNode
----------------------------

~~~scala
trait OutwardNode[DO, UO, BO <: Data] extends BaseNode with OutwardNodeHandle[DO, UO, BO]
~~~

+ **outward** `OutwardNode[DO, UO, BO] = this` pointer to the LazyModule.
+ **numPO** `Range.Inclusive` (virtual) number of putputs.
+ **oPushed** `() => Int` number of outer nodes being processed.
+ **oPush** `(index: Int, node: InwardNode [DO, UO, BO], binding: NodeBinding) => Unit`<br>
  Process a port connection.
+ **oBindings** `List[(Int, InwardNode [DO, UO, BO], NodeBinding)]`<br>
  (lazy) A list of input port to be binded (index, port, bind-type)
+ **oStar** `Int` (virtual) ??
+ **oPortMapping** `Seq[(Int, Int)]` (virtual) range of each output port.
+ **oParams** `Seq[DO]` (virtual) output port node parameters.
+ **bundleOut** `Vec[BO]` (virtual) the actual heterogeneous list of output port Bundles in hardware.


abstract class MixedNode
---------------------------
~~~scala
abstract class MixedNode[DI, UI, EI, BI <: Data, DO, UO, EO, BO <: Data](
    inner: InwardNodeImp [DI, UI, EI, BI],
    outer: OutwardNodeImp[DO, UO, EO, BO])(
    protected[diplomacy] val numPO: Range.Inclusive,
    protected[diplomacy] val numPI: Range.Inclusive)
    extends BaseNode with InwardNode[DI, UI, BI] with OutwardNode[DO, UO, BO]
~~~

+ **inner** `InwardNodeImp [DI, UI, EI, BI]` (param) input node parameters.
+ **outer** `OutwardNodeImp[DO, UO, EO, BO]` (param) output node parameters.
+ **numPO** `Range.Inclusive` (param) output range.
+ **numPI** `Range.Inclusive` (param) input range.
+ **resolveStar** `(iKown:Int, oKnown:Int, iStars:Int, oStars:Int) => (iStar:Int, oStar:Int)`<br>
  (virtual) A function to resolve the number of star type input and output ports.
+ **mapParamsD** `(Int, Seq[DI]) => Seq[DO]`<br>
  (virtual) A function to resolve oParams.
+ **mapParamsU** `(Int, Seq[DO]) => Seq[DI]`<br>
  (virtual) A function to resolve iParams.
+ **oPortMapping** `Seq[(Int, Int)]` (lazy)range of each output port.
+ **iPortMapping** `Seq[(Int, Int)]` (lazy)range of each input port.
+ **oStar** `Int` (lazy) ??
+ **iStar** `Int` (lazy) ??
+ **oPorts** `Seq[(Int, InwardNode [DI, UI, BI])]` (lazy) a list of (index, port) binded by its output ports.
+ **iPorts** `Seq[(Int, OutwardNode [DO, UO, BO])]` (lazy) a list of (index, port) binded by its input ports.
+ **oParams** `Seq[DO]` (lazy) output port node parameters.
+ **iParams** `Seq[DI]` (lazy) input port node parameters.
+ **edgesOut** `Seq[EO]` (lazy) output port edge parameters.
+ **edgesIn** `Seq[EI]` (lazy) input port edge parameters.
+ **externalEdgesOut** `Seq[EO]` (lazy) output edge parameter for external port connection.
+ **externalEdgesIn** `Seq[EI]` (lazy) input edge parameter for external port connection.
+ **flip** `Boolean = false` flip the port directions (needed for blind nodes).
+ **wire** `Boolean = false` wire the ports if you want to grab access to from inside a module.
+ **bunleOut** `Seq[BO]` output bundles.
+ **bundleIn** `Seq[BI]` input bundles.


+ **connectButDontMonitor** `(h: OutwardNodeHandle[DI, UI, BI]) => Option[MonitorBase]`<br>
  Equal to `:=` but without a monitor.
+ **:=** `(h: OutwardNodeHandle[DI, UI, BI]) => Option[MonitorBase]`<br>
  Connect `h` to the only output port of this, 1 to 1 connection. Add a monitor.
~~~
(h)-->(x)
x.iPush(h, BIND_ONCE)
h.oPush(x, BIND_ONCE)
~~~
+ **&ast;=** `(h: OutwardNodeHandle[DI, UI, BI]) => Option[MonitorBase]`<br>
  Connect `h` to all output ports of this, 1 output to M input connection. Add a monitor.
~~~
(h)-->(x,...)
x.iPush(h, BIND_STAR)
h.oPush(x, BIND_QUERY)
~~~
+ **=&ast;** `(h: OutwardNodeHandle[DI, UI, BI]) => Option[MonitorBase]`<br>
  Add `h` to the input ports list of this, M output to 1 input connection. Add a monitor.
~~~
(h,...)-->(x)
x.iPush(h, BIND_QUERY)
h.oPush(x, BIND_STAR)
~~~


Reference: https://github.com/freechipsproject/rocket-chip/pull/536
>In some places we would like to pass multiple connections through an edge.
>
>For example, at the TL master port for the Coreplex, we want to accept multiple masters that are then connected to the l1tol2 crossbar. However, within the Coreplex we do not know how many such edges are needed.
>
>For some time, diplomacy has supported multiple connections via a single Node. However, there was no way to leverage this for a flexible number of connections. This patch changes that.
>
>foo :=* bar // indicates that foo should be connected to bar as many times as bar requires<br>
>bar := baz1<br>
>bar := baz2 // there will be two connections from bar to foo
>
>foo :*= bar // indicates that bar should be connected to foo as many times as foo requires<br>
>baz1 := foo<br>
>baz2 := foo // two times


## class MixedAdapterNode
*Generic bus adapters.*

~~~scala
class MixedAdapterNode[DI, UI, EI, BI <: Data, DO, UO, EO, BO <: Data](
  inner: InwardNodeImp [DI, UI, EI, BI],
  outer: OutwardNodeImp[DO, UO, EO, BO])(
  dFn: DI => DO,
  uFn: UO => UI,
  num: Range.Inclusive = 0 to 999)
  extends MixedNode(inner, outer)(num, num)
~~~
+ **inner** `InwardNodeImp [DI, UI, EI, BI]` (param) input node (manager side) parameters.
+ **outer** `OutwardNodeImp[DO, UO, EO, BO]` (param) output node (client side) parameters.
+ **dFn** `(DI) => DO` used to resolve oParams.
+ **uFn** `(DO) => DI` used to resolve iParams.
+ **num** `Range.Inclusive = 1 to 999` (param) input and output range.
+ **resolveStar** `(iKown:Int, oKnown:Int, iStars:Int, oStars:Int) => (iStar:Int, oStar:Int)`<br>
  (**_not sure why <=1 star binding is allowed_**)
+ **mapParamsD** `(Int, p:Seq[DI]) => Seq[DO]` resolve oParams using dFn(), resolve port individually.
+ **mapParamsU** `(Int, p:Seq[DO]) => Seq[DI]` resolve iParams using uFn(), resolve port individually.


## class MixedNexusNode
*Generic class of switches.*

~~~scala
class MixedNexusNode[DI, UI, EI, BI <: Data, DO, UO, EO, BO <: Data](
  inner: InwardNodeImp [DI, UI, EI, BI],
  outer: OutwardNodeImp[DO, UO, EO, BO])(
  dFn: Seq[DI] => DO,
  uFn: Seq[UO] => UI,
  numPO: Range.Inclusive = 1 to 999,
  numPI: Range.Inclusive = 1 to 999)
  extends MixedNode(inner, outer)(numPO, numPI)
~~~

+ **inner** `InwardNodeImp [DI, UI, EI, BI]` (param) input node parameters.
+ **outer** `OutwardNodeImp[DO, UO, EO, BO]` (param) output node parameters.
+ **dFn** `(Seq[DI]) => DO` used to resolve oParams.
+ **uFn** `(Seq[UO]) => UI` used to resolve iParams.
+ **numPO** `Range.Inclusive = 1 to 999` (param) output range.
+ **numPI** `Range.Inclusive = 1 to 999` (param) input range.
+ **externalIn** `Boolean = true` generate external input port bundles.
+ **externalOut** `Boolean = true` generate external output port bundles.
+ **resolveStar** `(iKown:Int, oKnown:Int, iStars:Int, oStars:Int) => (iStar:Int, oStar:Int)`<br>
  resolve `iStar` and `oStar`. NexusNode does not allow any input or output star connections.
+ **mapParamsD** `(Int, p:Seq[DI]) => Seq[DO]` resolve oParams using dFn().
+ **mapParamsU** `(Int, p:Seq[DO]) => Seq[DI]` resolve iParams using uFn().
+ **oStar** `Int = 0` (const)
+ **iStar** `Int = 0` (const)



## class AdapterNode
*Base node class for a bus adapter.*

~~~scala
class AdapterNode[D, U, EO, EI, B <: Data](imp: NodeImp[D, U, EO, EI, B])(
  dFn: D => D,
  uFn: U => U,
  num: Range.Inclusive = 0 to 999)
    extends MixedAdapterNode[D, U, EI, B, D, U, EO, B](imp, imp)(dFn, uFn, num)
~~~

## class NexusNode
*Base node for a switch node (crossbar, multiplexer ordemultiplexer).*

~~~scala
class NexusNode[D, U, EO, EI, B <: Data](imp: NodeImp[D, U, EO, EI, B])(
  dFn: Seq[D] => D,
  uFn: Seq[U] => U,
  numPO: Range.Inclusive = 1 to 999,
  numPI: Range.Inclusive = 1 to 999)
    extends MixedNexusNode[D, U, EI, B, D, U, EO, B](imp, imp)(dFn, uFn, numPO, numPI)
~~~

## case class SplitterArg

~~~scala
case class SplitterArg[T](newSize: Int, ports: Seq[T])
~~~

+ **newSize** `Int` (param) number of output channels (Upwards or downwards depending on T).
+ **ports** `T` (param) port parameter (D and U).

## class MixedSplitterNode
*Demultiplexer for complicate channel bundles.*

oParams.size == N * iParams.size, where N is a positive integer.

~~~scala
class MixedSplitterNode[DI, UI, EI, BI <: Data, DO, UO, EO, BO <: Data](
  inner: InwardNodeImp [DI, UI, EI, BI],
  outer: OutwardNodeImp[DO, UO, EO, BO])(
  dFn: SplitterArg[DI] => Seq[DO],
  uFn: SplitterArg[UO] => Seq[UI],
  numPO: Range.Inclusive = 1 to 999,
  numPI: Range.Inclusive = 1 to 999)
  extends MixedNode(inner, outer)(numPO, numPI)
~~~

+ **inner** `InwardNodeImp [DI, UI, EI, BI]` (param) input node parameters.
+ **outer** `OutwardNodeImp[DO, UO, EO, BO]` (param) output node parameters.
+ **dFn** `(SplitterArg[DI]) => DO` used to resolve oParams.
+ **uFn** `(SplitterArg[UO]) => UI` used to resolve iParams.
+ **numPO** `Range.Inclusive = 1 to 999` (param) output range.
+ **numPI** `Range.Inclusive = 1 to 999` (param) input range.
+ **externalIn** `Boolean = true` generate external input port bundles.
+ **externalOut** `Boolean = true` generate external output port bundles.
+ **resolveStar** `(iKown:Int, oKnown:Int, iStars:Int, oStars:Int) => (iStar:Int, oStar:Int)`<br>
  resolve `iStar` and `oStar`. `iStar <= 0, oStar <= iKown`.
+ **mapParamsD** `(ps:Int, p:Seq[DI]) => Seq[DO]` resolve oParams using number of ports (ps) and dFn().
+ **mapParamsU** `(ps:Int, p:Seq[DO]) => Seq[DI]` resolve iParams using number of ports (ps) and uFn().

## class SplitterNode

~~~scala
class SplitterNode[D, U, EO, EI, B <: Data](imp: NodeImp[D, U, EO, EI, B])(
  dFn: SplitterArg[D] => Seq[D],
  uFn: SplitterArg[U] => Seq[U],
  numPO: Range.Inclusive = 1 to 999,
  numPI: Range.Inclusive = 1 to 999)
    extends MixedSplitterNode[D, U, EI, B, D, U, EO, B](imp, imp)(dFn, uFn, numPO, numPI)
~~~

## class IdentityNode

~~~scala
class IdentityNode[D, U, EO, EI, B <: Data](imp: NodeImp[D, U, EO, EI, B])
  extends AdapterNode(imp)({s => s}, {s => s})
~~~

## class OutputNode

~~~scala
class OutputNode[D, U, EO, EI, B <: Data](imp: NodeImp[D, U, EO, EI, B])
    extends IdentityNode(imp)
~~~

class InputNode
----------

~~~scala
class InputNode[D, U, EO, EI, B <: Data](imp: NodeImp[D, U, EO, EI, B])
    extends IdentityNode(imp)
~~~

class SourceNode
------------

~~~scala
class SourceNode[D, U, EO, EI, B <: Data](imp: NodeImp[D, U, EO, EI, B])(po: Seq[D])
  extends MixedNode(imp, imp)(po.size to po.size, 0 to 0)
~~~

class SinkNode
-----------

~~~scala
class SinkNode[D, U, EO, EI, B <: Data](imp: NodeImp[D, U, EO, EI, B])(pi: Seq[U])
  extends MixedNode(imp, imp)(0 to 0, pi.size to pi.size)
~~~



<br><br><br><p align="right">
<sub>
Last updated: 20/07/2017<br>
[CC-BY](https://creativecommons.org/licenses/by/3.0/), &copy; (2017) [Wei Song](mailto:wsong83@gmail.com)<br>
[Apache 2.0](https://github.com/freechipsproject/rocket-chip/blob/master/LICENSE.SiFive), &copy; (2016-2017) SiFive, Inc<br>
[BSD](https://github.com/freechipsproject/rocket-chip/blob/master/LICENSE.Berkeley), &copy; (2012-2014, 2016) The Regents of the University of California (Regents)
</sub>
</p>
