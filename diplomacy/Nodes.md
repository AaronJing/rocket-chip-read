[Rocket](../Readme.md)/[diplomacy](../diplomacy.md)/[Node](https://github.com/freechipsproject/rocket-chip/blob/master/src/main/scala/diplomacy/Nodes.scala)
=====================
*The base classes of nodes on on-chip interconnects.*

**********************

trait InwardNodeImp
-------------------------------
*Typeclass for nodes with input channels.*

~~~scala
trait InwardNodeImp[DI, UI, EI, BI <: Data]
~~~

+ **DI** Downwards flowing Parameters received on the inner side of the node
+ **UI** Upwards flowing Parameters generated by the inner side of the node
+ **EI** Packet parameters (generators) for this node.
+ **BI** Bundle type
<br><br>
+ **edgeI** `(pd: DI, pu: UI) => EI` get the parameters for an input channel.
+ **bundleI** `(ei: EI) => BI` generate the input channel.
+ **colour** `_ => String` get the color in node connection graph.
+ **connect** `(()=>Seq[EI], ()=>Seq[(BI, BI)], enM:Boolean) => (m:Option[LazyModule], bind:()=>Unit)`<br>
    Generate the port connection callback function _bind()_<br>
    _enM_: whether to insert a bus monitor.<br>
    _m_: The optional monitor node to be connected.<br>
    _bind_: The actual connection procedure to be called later by LazyModule.

trait OutwardNodeImp
------------------------------
*Typeclass for nodes with output channels.*

~~~scala
trait OutwardNodeImp[DO, UO, EO, BO <: Data]
~~~

+ **DO** Downwards flowing Parameters generated by the outer side of the node
+ **UO** Upwards   flowing Parameters received on the outer side of the node
+ **EO** Edge Parameters describing a connection on the outer side of the node
+ **BO** Bundle type used when connecting to the outer side of the node
<br><br>
+ **edgeO** `(pd: DO, pu: UO) => EO` get the parameters for an output channel.
+ **bundleO** `(eo: EO) => BO` generate the output channel.

abstract class NodeImp
--------------------------------
*Abstract root of nodes*

~~~scala
abstract class NodeImp[D, U, EO, EI, B <: Data]
  extends Object with InwardNodeImp[D, U, EI, B] with OutwardNodeImp[D, U, EO, B]
~~~

~~~diff
- Why differ EO and EI but not B?
~~~

abstract class BaseNode
---------------------------
*Base class of all Node parameter*

+ **lazyModule** `LazyModule` pointer to the parent lazyModule for error report.
+ **index** `Int` index of this node in stack.
+ **externalIn** `Boolean` generate input bundle for port connection.
+ **externalOut** `Boolean` generate output bundle for port connection.
+ **nodename** `() => String` node name
+ **name** `() => String` hierarchical node name
+ **omitGraphML** `() => Bool` a portless node does not need a connection graph
+ **gci** `() => Option[BaseNode]` get the greatest common inner node type
+ **gco** `() => Option[BaseNode]` get the greatest common outer node type
+ **outputs** `() => Seq[(BaseNode, String)]` list of outer nodes
+ **inputs** `() => Seq[(BaseNode, String)]` list of inner nodes
+ **colour** `() => String` node color



case class NodeHandle
---------------------------

~~~scala
case class NodeHandle[DI, UI, BI <: Data, DO, UO, BO <: Data]
    (inward: InwardNode[DI, UI, BI], outward: OutwardNode[DO, UO, BO])
    extends Object with InwardNodeHandle[DI, UI, BI] with OutwardNodeHandle[DO, UO, BO]
~~~

trait NodeBinding
---------------------------
*Always look from the input port's perspective.*

~~~scala
sealed trait NodeBinding
case object BIND_ONCE  extends NodeBinding
case object BIND_QUERY extends NodeBinding
case object BIND_STAR  extends NodeBinding
~~~

+ **BIND\_ONCE** normal one to one connection.
+ **BIND\_QUERY**  M to 1 connection, multiplexing.
+ **BIND\_STAR** 1 to M connection, demultiplexing.


trait InwardNodeHandle
---------------------------

~~~scala
trait InwardNodeHandle[DI, UI, BI <: Data]
{
    val inward: InwardNode[DI, UI, BI]
}
~~~

+ *inward: InwardNode[DI, UI, BI]*: self object pointer
+ **:=** `(h: OutwardNodeHandle[DI, UI, BI]) => Option[LazyModule]`<br>
  Connect `h` to the only output port of this, 1 to 1 connection.
+ **&ast;=** `(h: OutwardNodeHandle[DI, UI, BI]) => Option[LazyModule]`<br>
  Connect `h` to all output ports of this, 1 to M connection.
+ **=&ast;** `(h: OutwardNodeHandle[DI, UI, BI]) => Option[LazyModule]`<br>
  Add `h` to the input ports list of this, M to 1 connection.

Reference: https://github.com/freechipsproject/rocket-chip/pull/536
>In some places we would like to pass multiple connections through an edge.
>
>For example, at the TL master port for the Coreplex, we want to accept multiple masters that are then connected to the l1tol2 crossbar. However, within the Coreplex we do not know how many such edges are needed.
>
>For some time, diplomacy has supported multiple connections via a single Node. However, there was no way to leverage this for a flexible number of connections. This patch changes that.
>
>foo :=* bar // indicates that foo should be connected to bar as many times as bar requires<br>
>bar := baz1<br>
>bar := baz2 // there will be two connections from bar to foo
>
>foo :*= bar // indicates that bar should be connected to foo as many times as foo requires<br>
>baz1 := foo<br>
>baz2 := foo // two times

trait InwardNode
------------------------

~~~scala
trait InwardNode[DI, UI, BI <: Data] extends BaseNode with InwardNodeHandle[DI, UI, BI]
~~~

+ **inward** `InwardNode[DI, UI, BI] = this` pointer to the LazyModule.
+ **numPI** `Range.Inclusive` range of input ports.
+ **iPushed** `() => Int` number of inner nodes being processed.
+ **iPush** `(node:Int, node: OutwardNode[DI, UI, BI], binding: NodeBinding) => Unit` process a port connection.
+ **iBindings** `List[(Int, OutwardNode[DI, UI, BI], NodeBinding)]` list of output ports to be binded (index, port, bind-type).
+ **iStar** `Int` ??
+ **iPortMapping** `Seq[(Int, Int)]` range of each inner node.
+ **iParams** `Seq[UI]` inner node parameters.
+ **bundleIn** `Vec[BI]` (lazy) the actual heterogeneous list of input port Bundles in hardware.

trait OutwardNodeHandle
---------------------------

~~~scala
trait OutwardNodeHandle[DO, UO, BO <: Data]
{
  val outward: OutwardNode[DO, UO, BO]
}
~~~

+ **outward** `OutwardNode[DO, UO, BO]` pointer to the LazyModule.


trait OutwardNode
----------------------------

~~~scala
trait OutwardNode[DO, UO, BO <: Data] extends BaseNode with OutwardNodeHandle[DO, UO, BO]
~~~

+ **outward** `OutwardNode[DO, UO, BO] = this` pointer to the LazyModule.
+ **numPO** `Range.Inclusive` number of putputs.
+ **oPushed** `() => Int` number of outer nodes being processed.
+ **oPush** `(index: Int, node: InwardNode [DO, UO, BO], binding: NodeBinding) => Unit` process a port connection.
+ **oBindings** `List[(Int, InwardNode [DO, UO, BO], NodeBinding)]` list of input port to be binded (index, port, bind-type)
+ **oStar** `Int` ??
+ **oPortMapping** `Seq[(Int, Int)]` range of each outer node.
+ **oParams** `Seq[DO]` outer node parameters.
+ **bundleOut** `Vec[BO]` (lazy) the actual heterogeneous list of output port Bundles in hardware.


abstract class MixedNode
---------------------------
~~~scala
abstract class MixedNode[DI, UI, EI, BI <: Data, DO, UO, EO, BO <: Data](
    inner: InwardNodeImp [DI, UI, EI, BI],
    outer: OutwardNodeImp[DO, UO, EO, BO])(
    protected[diplomacy] val numPO: Range.Inclusive,
    protected[diplomacy] val numPI: Range.Inclusive)
    extends BaseNode with InwardNode[DI, UI, BI] with OutwardNode[DO, UO, BO]
~~~

+ **oPorts** `Seq[(Int, InwardNode [DO, UO, BO])]` (lazy) a list of (index, port) binded by its output ports.
+ **iPorts** `Seq[(Int, OutwardNode [DO, UO, BO])]` (lazy) a list of (index, port) binded by its input ports.

class MixedAdapterNode
-----------

~~~scala
class MixedAdapterNode[DI, UI, EI, BI <: Data, DO, UO, EO, BO <: Data](
  inner: InwardNodeImp [DI, UI, EI, BI],
  outer: OutwardNodeImp[DO, UO, EO, BO])(
  dFn: DI => DO,
  uFn: UO => UI,
  num: Range.Inclusive = 0 to 999)
  extends MixedNode(inner, outer)(num, num)
~~~

class AdapterNode
-----------
*Base node class for a bus adapter.*

~~~scala
class AdapterNode[D, U, EO, EI, B <: Data](imp: NodeImp[D, U, EO, EI, B])(
  dFn: D => D,
  uFn: U => U,
  num: Range.Inclusive = 0 to 999)
    extends MixedAdapterNode[D, U, EI, B, D, U, EO, B](imp, imp)(dFn, uFn, num)
~~~

class NexusNode
-----------
*Base node for a switch node (crossbar, multiplexer ordemultiplexer).*

~~~scala
class NexusNode[D, U, EO, EI, B <: Data](imp: NodeImp[D, U, EO, EI, B])(
  dFn: Seq[D] => D,
  uFn: Seq[U] => U,
  numPO: Range.Inclusive = 1 to 999,
  numPI: Range.Inclusive = 1 to 999)
    extends MixedNexusNode[D, U, EI, B, D, U, EO, B](imp, imp)(dFn, uFn, numPO, numPI)
~~~

class IdentityNode
-----------

~~~scala
class IdentityNode[D, U, EO, EI, B <: Data](imp: NodeImp[D, U, EO, EI, B])
  extends AdapterNode(imp)({s => s}, {s => s})
~~~

class OutputNode
-------------

~~~scala
class OutputNode[D, U, EO, EI, B <: Data](imp: NodeImp[D, U, EO, EI, B])
    extends IdentityNode(imp)
~~~

class InputNode
----------

~~~scala
class InputNode[D, U, EO, EI, B <: Data](imp: NodeImp[D, U, EO, EI, B])
    extends IdentityNode(imp)
~~~

class SourceNode
------------

~~~scala
class SourceNode[D, U, EO, EI, B <: Data](imp: NodeImp[D, U, EO, EI, B])(po: Seq[D])
  extends MixedNode(imp, imp)(po.size to po.size, 0 to 0)
~~~

class SinkNode
-----------

~~~scala
class SinkNode[D, U, EO, EI, B <: Data](imp: NodeImp[D, U, EO, EI, B])(pi: Seq[U])
  extends MixedNode(imp, imp)(0 to 0, pi.size to pi.size)
~~~



<br><br><br><p align="right">
<sub>
Last updated: 13/07/2017<br>
[CC-BY](https://creativecommons.org/licenses/by/3.0/), &copy; (2017) [Wei Song](mailto:wsong83@gmail.com)<br>
[Apache 2.0](https://github.com/freechipsproject/rocket-chip/blob/master/LICENSE.SiFive), &copy; (2016-2017) SiFive, Inc<br>
[BSD](https://github.com/freechipsproject/rocket-chip/blob/master/LICENSE.Berkeley), &copy; (2012-2014, 2016) The Regents of the University of California (Regents)
</sub>
</p>
