[Rocket](../Readme.md)/[diplomacy](../diplomacy.md)/[Node](https://github.com/ucb-bar/rocket-chip/blob/master/src/main/scala/diplomacy/Nodes.scala)
=====================

**********************

trait InwardNodeImp[DI, UI, EI, BI <: Data]
-------------------------------
*Typeclass for nodes with input channels.*

### Type variables:

+ **DI** Downwards flowing Parameters received on the inner side of the node
+ **UI** Upwards flowing Parameters generated by the inner side of the node
+ **EI** Edge Parameters describing a connection on the inner side of the node
+ **BI** Bundle type used when connecting to the inner side of the node

### Member variables and functions:

+ **edgeI** `(pd: DI, pu: UI) => EI`

    Get the parameters for an input channel.

+ **bundleI** `(ei: EI) => BI`

    Generate the input channel.

+ **colour** `_ => String`

    Get the color in node connection graph.

+ **connect** `(bindings: () => Seq[(EI, BI, BI)]) => (Option[LazyModule], () => Unit)`

    The callback for the actually binding operation.
    For the return value, `Option[LazyModule]` is used to define a bus monitor?
    `() => Unit` is the port connection callback which is processed after LazyModules emit Modules.

trait OutwardNodeImp[DO, UO, EO, BO <: Data]
------------------------------
*Typeclass for nodes with output channels.*

### Type variables:

+ **DO** Downwards flowing Parameters generated by the outer side of the node
+ **UO** Upwards   flowing Parameters received on the outer side of the node
+ **EO** Edge Parameters describing a connection on the outer side of the node
+ **BO** Bundle type used when connecting to the outer side of the node

### Member variables and functions:

+ **edgeO** `(pd: DO, pu: UO) => EO`

    Get the parameters for an output channel.

+ **bundleO** `(eo: EO) => BO`

    Generate the output channel.

abstract class NodeImp[D, U, EO, EI, B <: Data]
--------------------------------
    abstract class NodeImp[D, U, EO, EI, B <: Data]
      extends Object with InwardNodeImp[D, U, EI, B] with OutwardNodeImp[D, U, EO, B]

abstract class BaseNode
---------------------------
*Base class of all Node classes*

+ *lazyModule: LazyModule*: ??
+ *index: Int*: ??
+ *externalIn: Boolean*: ??
+ *externalOut: Boolean*: ??
+ *nodename: _ => String*: get node name
+ *name: _ => String*: get hierarchical node name ??
+ *omitGraphML: _ => Bool*: omit graph generation when no inner or no outer nodes
+ *gci: _ => Option[BaseNode]*: get the greatest common inner node type
+ *gco: _ => Option[BaseNode]*: get the greatest common outer node type
+ *outputs: _ => Seq[(BaseNode, String)]*: list of outer nodes
+ *inputs: _ => Seq[(BaseNode, String)]*: list of inner nodes
+ *colour: _ => String*: node color



case class NodeHandle[DI, UI, BI <: Data, DO, UO, BO <: Data]
---------------------------
    case class NodeHandle[DI, UI, BI <: Data, DO, UO, BO <: Data]
      (inward: InwardNode[DI, UI, BI], outward: OutwardNode[DO, UO, BO])
      extends Object with InwardNodeHandle[DI, UI, BI] with OutwardNodeHandle[DO, UO, BO]


case object BIND\_ONCE
---------------------------------
*Normal one to one connection*

case object BIND\_QUERY
---------------------------------
*A shared sink port?*

case object BIND\_STAR
---------------------------------
*A shared source port?*


trait InwardNodeHandle[DI, UI, BI <: Data]
---------------------------

+ *inward: InwardNode[DI, UI, BI]*: self object pointer
+ **:=** `(h: OutwardNodeHandle[DI, UI, BI]) => Option[LazyModule]`

    Connect this input port to an output port `h`.

+ **&ast;=** `(h: OutwardNodeHandle[DI, UI, BI]) => Option[LazyModule]`

    Connect this input multi-port to an output `h`??

+ **=&ast;** `(h: OutwardNodeHandle[DI, UI, BI]) => Option[LazyModule]`

    Connect this input port to an output multi-port `h`??


trait InwardNode[DI, UI, BI <: Data]
------------------------
    trait InwardNode[DI, UI, BI <: Data] extends BaseNode with InwardNodeHandle[DI, UI, BI]

+ *inward: InwardNode[DI, UI, BI]*: self object pointer
+ *numPI: Range.Inclusive*: number of inner nodes (numPI >= 0)
+ *iPushed: _ => Int*: number of inner nodes being processed
+ *iPush: (node:Int, node: OutwardNode[DI, UI, BI], binding: NodeBinding) => Unit*: process an inner node
+ *iBindings: List[(Int, OutwardNode[DI, UI, BI], NodeBinding)]*: list of inner nodes (index, input, binding)
+ *iStar: Int*: ??
+ *iPortMapping: Seq[(Int, Int)]*: range of each inner nodes
+ *iParams: Seq[UI]*: inner node parameters
+ *bundleIn: Vec[BI]*: inner node bundles

trait OutwardNodeHandle[DO, UO, BO <: Data]
---------------------------

+ *outward: OutwardNode[DO, UO, BO]*: self object pointer


trait OutwardNode[DO, UO, BO <: Data]
----------------------------
    trait OutwardNode[DO, UO, BO <: Data] extends BaseNode with OutwardNodeHandle[DO, UO, BO]

+ *outward: OutwardNode[DO, UO, BO]*: self object pointer
+ *numPO: Range.Inclusive*: number of putputs (numPO >= 0)
+ *oPushed: _ => Int*: number of outer nodes being processed
+ *oPush: (index: Int, node: InwardNode [DO, UO, BO], binding: NodeBinding) => Unit*: process an outer node
+ *oBindings: List[(Int, InwardNode [DO, UO, BO], NodeBinding)]*: list of outer nodes (index, output, binding)
+ *oStar: Int*: ??
+ *oPortMapping: Seq[(Int, Int)]*: Range of each outer nodes
+ *oParams: Seq[DO]*: outer node parameters
+ *bundleOut: vec[BO]*: outer node bundles


abstract class MixedNode[DI, UI, EI, BI <: Data, DO, UO, EO, BO <: Data]
---------------------------
~~~scala
abstract class MixedNode[DI, UI, EI, BI <: Data, DO, UO, EO, BO <: Data](
    inner: InwardNodeImp [DI, UI, EI, BI],
    outer: OutwardNodeImp[DO, UO, EO, BO])(
    protected[diplomacy] val numPO: Range.Inclusive,
    protected[diplomacy] val numPI: Range.Inclusive)
    extends BaseNode with InwardNode[DI, UI, BI] with OutwardNode[DO, UO, BO]
~~~

+ *oPorts: (Int, (Int, InwardNode [DO, UO, BO]))*: mapping from outer node to inner nodes?
+ *iPorts: (Int, (Int, OutwardNode [DO, UO, BO]))*: mapping from inner node to outer nodes?

....

**********************

```scala
last modified = 27/03/2017
authors       = Wei Song <wsong83@gmail.com>
license       = CC-BY <https://creativecommons.org/licenses/by/3.0/>
```
