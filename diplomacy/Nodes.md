[Rocket](../Readme.md)/[diplomacy](../diplomacy.md)/[Node](https://github.com/freechipsproject/rocket-chip/blob/master/src/main/scala/diplomacy/Nodes.scala)
=====================
*The base classes of nodes on on-chip interconnects.*

**********************

trait InwardNodeImp
-------------------------------
*Typeclass for nodes with input channels.*

~~~scala
trait InwardNodeImp[DI, UI, EI, BI <: Data]
~~~

+ **DI** Downwards flowing Parameters received on the inner side of the node
+ **UI** Upwards flowing Parameters generated by the inner side of the node
+ **EI** Packet parameters (generators) for this node.
+ **BI** Bundle type
<br><br>
+ **edgeI** `(pd: DI, pu: UI) => EI`<br>
    Get the parameters for an input channel.
+ **bundleI** `(ei: EI) => BI`<br>
    Generate the input channel.
+ **colour** `_ => String`<br>
    Get the color in node connection graph.
+ **connect** `(bindings: () => Seq[(EI, BI, BI)]) => (monitor:Option[LazyModule], bind:() => Unit)`<br>
    The callback for the actually binding operation.<br>
    _bindings_: (packet parameter, input channel, output channel), the pairs of channels to be connected.<br>
    _monitor_: The optional monitor node to be connected.<br>
    _bind_: The actual connection procedure to be called later by LazyModule.

trait OutwardNodeImp
------------------------------
*Typeclass for nodes with output channels.*

~~~scala
trait OutwardNodeImp[DO, UO, EO, BO <: Data]
~~~

+ **DO** Downwards flowing Parameters generated by the outer side of the node
+ **UO** Upwards   flowing Parameters received on the outer side of the node
+ **EO** Edge Parameters describing a connection on the outer side of the node
+ **BO** Bundle type used when connecting to the outer side of the node
<br><br>
+ **edgeO** `(pd: DO, pu: UO) => EO`<br>
    Get the parameters for an output channel.
+ **bundleO** `(eo: EO) => BO`<br>
    Generate the output channel.

abstract class NodeImp
--------------------------------
*Abstract root of nodes*

~~~scala
abstract class NodeImp[D, U, EO, EI, B <: Data]
  extends Object with InwardNodeImp[D, U, EI, B] with OutwardNodeImp[D, U, EO, B]
~~~

~~~diff
- Why differ EO and EI but not B?
~~~

abstract class BaseNode
---------------------------
*Base class of all Node parameter*

+ **lazyModule** `LazyModule` pointer to the lazyModule
+ **index** `Int` index of the node in this lazyModule (think about the index of a port in a crossbar)
+ **externalIn** `Boolean` ??
+ **externalOut** `Boolean` ??
+ **nodename** `() => String` node name
+ **name** `() => String` hierarchical node name
+ **omitGraphML** `() => Bool` a portless node does not need a connection graph
+ **gci** `() => Option[BaseNode]` get the greatest common inner node type
+ **gco** `() => Option[BaseNode]` get the greatest common outer node type
+ **outputs** `() => Seq[(BaseNode, String)]` list of outer nodes
+ **inputs** `() => Seq[(BaseNode, String)]` list of inner nodes
+ **colour** `() => String` node color



case class NodeHandle
---------------------------

~~~scala
case class NodeHandle[DI, UI, BI <: Data, DO, UO, BO <: Data]
    (inward: InwardNode[DI, UI, BI], outward: OutwardNode[DO, UO, BO])
    extends Object with InwardNodeHandle[DI, UI, BI] with OutwardNodeHandle[DO, UO, BO]
~~~

Connection types
---------------------------
*Always look from the input port's perspective.*

+ **BIND\_ONCE**<br>
  Normal one to one connection.
+ **BIND\_QUERY**<br>
  M to 1 connection, multiplexing.
+ **BIND\_STAR**<br>
  1 to M connection, demultiplexing.


trait InwardNodeHandle
---------------------------

+ *inward: InwardNode[DI, UI, BI]*: self object pointer
+ **:=** `(h: OutwardNodeHandle[DI, UI, BI]) => Option[LazyModule]`<br>
  Connect `h` to the only output port of this, 1 to 1 connection.
+ **&ast;=** `(h: OutwardNodeHandle[DI, UI, BI]) => Option[LazyModule]`<br>
  Connect `h` to all output ports of this, 1 to M connection.
+ **=&ast;** `(h: OutwardNodeHandle[DI, UI, BI]) => Option[LazyModule]`<br>
  Add `h` to the input ports list of this, M to 1 connection.

Reference: https://github.com/freechipsproject/rocket-chip/pull/536
>In some places we would like to pass multiple connections through an edge.
>
>For example, at the TL master port for the Coreplex, we want to accept multiple masters that are then connected to the l1tol2 crossbar. However, within the Coreplex we do not know how many such edges are needed.
>
>For some time, diplomacy has supported multiple connections via a single Node. However, there was no way to leverage this for a flexible number of connections. This patch changes that.
>
>foo :=* bar // indicates that foo should be connected to bar as many times as bar requires<br>
>bar := baz1<br>
>bar := baz2 // there will be two connections from bar to foo
>
>foo :*= bar // indicates that bar should be connected to foo as many times as foo requires<br>
>baz1 := foo<br>
>baz2 := foo // two times

trait InwardNode
------------------------
    trait InwardNode[DI, UI, BI <: Data] extends BaseNode with InwardNodeHandle[DI, UI, BI]

+ *inward: InwardNode[DI, UI, BI]*: self object pointer
+ *numPI: Range.Inclusive*: number of inner nodes (numPI >= 0)
+ *iPushed: _ => Int*: number of inner nodes being processed
+ *iPush: (node:Int, node: OutwardNode[DI, UI, BI], binding: NodeBinding) => Unit*: process an inner node
+ *iBindings: List[(Int, OutwardNode[DI, UI, BI], NodeBinding)]*: list of inner nodes (index, input, binding)
+ *iStar: Int*: ??
+ *iPortMapping: Seq[(Int, Int)]*: range of each inner nodes
+ *iParams: Seq[UI]*: inner node parameters
+ *bundleIn: Vec[BI]*: inner node bundles

trait OutwardNodeHandle
---------------------------

+ *outward: OutwardNode[DO, UO, BO]*: self object pointer


trait OutwardNode
----------------------------
    trait OutwardNode[DO, UO, BO <: Data] extends BaseNode with OutwardNodeHandle[DO, UO, BO]

+ *outward: OutwardNode[DO, UO, BO]*: self object pointer
+ *numPO: Range.Inclusive*: number of putputs (numPO >= 0)
+ *oPushed: _ => Int*: number of outer nodes being processed
+ *oPush: (index: Int, node: InwardNode [DO, UO, BO], binding: NodeBinding) => Unit*: process an outer node
+ *oBindings: List[(Int, InwardNode [DO, UO, BO], NodeBinding)]*: list of outer nodes (index, output, binding)
+ *oStar: Int*: ??
+ *oPortMapping: Seq[(Int, Int)]*: Range of each outer nodes
+ *oParams: Seq[DO]*: outer node parameters
+ *bundleOut: vec[BO]*: outer node bundles


abstract class MixedNode
---------------------------
~~~scala
abstract class MixedNode[DI, UI, EI, BI <: Data, DO, UO, EO, BO <: Data](
    inner: InwardNodeImp [DI, UI, EI, BI],
    outer: OutwardNodeImp[DO, UO, EO, BO])(
    protected[diplomacy] val numPO: Range.Inclusive,
    protected[diplomacy] val numPI: Range.Inclusive)
    extends BaseNode with InwardNode[DI, UI, BI] with OutwardNode[DO, UO, BO]
~~~

+ *oPorts: (Int, (Int, InwardNode [DO, UO, BO]))*: mapping from outer node to inner nodes?
+ *iPorts: (Int, (Int, OutwardNode [DO, UO, BO]))*: mapping from inner node to outer nodes?

class MixedAdapterNode
-----------

~~~scala
class MixedAdapterNode[DI, UI, EI, BI <: Data, DO, UO, EO, BO <: Data](
  inner: InwardNodeImp [DI, UI, EI, BI],
  outer: OutwardNodeImp[DO, UO, EO, BO])(
  dFn: DI => DO,
  uFn: UO => UI,
  num: Range.Inclusive = 0 to 999)
  extends MixedNode(inner, outer)(num, num)
~~~

class AdapterNode
-----------
*Base node class for a bus adapter.*

~~~scala
class AdapterNode[D, U, EO, EI, B <: Data](imp: NodeImp[D, U, EO, EI, B])(
  dFn: D => D,
  uFn: U => U,
  num: Range.Inclusive = 0 to 999)
    extends MixedAdapterNode[D, U, EI, B, D, U, EO, B](imp, imp)(dFn, uFn, num)
~~~

class NexusNode
-----------
*Base node for a switch node (crossbar, multiplexer ordemultiplexer).*

~~~scala
class NexusNode[D, U, EO, EI, B <: Data](imp: NodeImp[D, U, EO, EI, B])(
  dFn: Seq[D] => D,
  uFn: Seq[U] => U,
  numPO: Range.Inclusive = 1 to 999,
  numPI: Range.Inclusive = 1 to 999)
    extends MixedNexusNode[D, U, EI, B, D, U, EO, B](imp, imp)(dFn, uFn, numPO, numPI)
~~~

class IdentityNode
-----------

~~~scala
class IdentityNode[D, U, EO, EI, B <: Data](imp: NodeImp[D, U, EO, EI, B])
  extends AdapterNode(imp)({s => s}, {s => s})
~~~

class OutputNode
-------------

~~~scala
class OutputNode[D, U, EO, EI, B <: Data](imp: NodeImp[D, U, EO, EI, B])
    extends IdentityNode(imp)
~~~

class InputNode
----------

~~~scala
class InputNode[D, U, EO, EI, B <: Data](imp: NodeImp[D, U, EO, EI, B])
    extends IdentityNode(imp)
~~~

class SourceNode
------------

~~~scala
class SourceNode[D, U, EO, EI, B <: Data](imp: NodeImp[D, U, EO, EI, B])(po: Seq[D])
  extends MixedNode(imp, imp)(po.size to po.size, 0 to 0)
~~~

class SinkNode
-----------

~~~scala
class SinkNode[D, U, EO, EI, B <: Data](imp: NodeImp[D, U, EO, EI, B])(pi: Seq[U])
  extends MixedNode(imp, imp)(0 to 0, pi.size to pi.size)
~~~



<br><br><br><p align="right"><sub>[CC-BY](https://creativecommons.org/licenses/by/3.0/), &copy; (2017) [Wei Song](mailto:wsong83@gmail.com), 20/06/2017</sub></p>
